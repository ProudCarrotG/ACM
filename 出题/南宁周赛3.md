# 注意仅给出了部分代码,源代码中均有`#define int long long`;

为什么要这样写?

因为这是一个悲伤的故事

# A

[Problem - D - Codeforces](https://codeforces.com/gym/104686/problem/D)

贪心

从下往上考虑

对于每个分支，记tot为珊瑚子节的长度和，反复执行以下操作并更新tot的值

-   tot>n时，将最长的子节单独切下作为一个部分
-   tot<=n时，将剩下的子节长度合并到当前珊瑚节上

对于当前珊瑚节，计算对答案的贡献，和剩下的长度

递归遍历一遍树就可以求出答案

```

int W;
int ans = 0;

struct node {
    int w;
    vector<int> son;
};
int idx = 0;

vector<node> tr(1e5 + 10);

void build() {
    int num = 0;
    int now = idx;
    cin >> tr[now].w >> num;

    for (int i = 0; i < num; i++) {
        idx++;
        tr[now].son.push_back(idx);
        build();
    }
}

void dfs(int now) {
    for (int i = 0; i < tr[now].son.size(); i++) {
        dfs(tr[now].son[i]);
    }

    vector<int> sonw;
    int tot = 0;
    for (int i = 0; i < tr[now].son.size(); i++) {
        int son = tr[now].son[i];
        tot += tr[son].w;
        sonw.push_back(tr[son].w);
    }

    sort(sonw.begin(), sonw.end());
    int id = sonw.size() - 1;

    while (tot > W) {
        ans++;
        tot -= sonw[id];
        id--;
    }

    tr[now].w += tot;

    ans += tr[now].w / W;
    tr[now].w = tr[now].w % W;
}

void solve() {
    cin >> W;

    build();

    dfs(0);

    cout << ans + (tr[0].w ? 1 : 0) << endl;
}
```





# B

询问次数很少

从这里出发，每次询问就递归的查找之前的操作

一直找到询问位置对应原串的位置

```
void solve() {
    int n, m;
    cin >> n >> m;

    string s;
    cin >> s;

    vector<pair<int, int>> op;

    auto check = [&](int x, int len) {
        if (x > len)
            return (char)-1;

        int id = op.size() - 1;
        while (x >= s.size()) {
            int oplen = op[id].r - op[id].l + 1;
            if (len - oplen <= x) {
                int tmp = len - 1 - x;
                x = op[id].l + tmp;
            }
            len -= oplen;
            id--;
        }
        return s[x];
    };

    int len = s.size();
    while (m--) {
        int o;
        cin >> o;
        if (o == 0) {
            int l, r;
            cin >> l >> r;
            op.push_back({l, r});
            len += r - l + 1;
        } else {
            int x;
            cin >> x;
            char ans = check(x, len);
            if (ans == -1)
                cout << -1 << endl;
            else
                cout << ans << endl;
        }
    }
}
```

# C

一个点与其他所有能到达的点的距离为r*p

500个点的多源最短路

弗洛伊德算法

注意题目数据量很大，使用cin输入需要关闭读入流

也要注意最大值的设置，int范围的最大值设置肯定是不够的（我设置的是longlong的最大值）

```

void solve() {
    int n, m;
    cin >> n >> m;
    vector<int> x(n + 1), y(n + 1), r(n + 1);
    vector<double> p(n + 1);
    vector<vector<double>> dis(n + 1, vector<double>(n + 1, LLONG_MAX));
    for (int i = 1; i <= n; i++) {
        cin >> x[i] >> y[i] >> r[i] >> p[i];
        dis[i][i] = 0;
    }

    auto reach = [&](int a, int b) {
        double dis = sqrt((x[a] - x[b]) * (x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b]));
        return (double)r[a] >= dis;
    };

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (reach(i, j) && i != j)
                dis[i][j] = r[i] * p[i];
        }
    }

    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++) {
                if (dis[i][k] != LLONG_MAX && dis[k][j] != LLONG_MAX)
                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
            }

    while (m--) {
        int a, b;
        cin >> a >> b;
        if (dis[a][b] == LLONG_MAX)
            cout << -1 << endl;
        else
            cout << dis[a][b] << endl;
    }
}
```

# D

签到

注意看清题就行

# E

我们发现1e12开三次方根的数值其实不是很大

毕竟是三次方级别

所以我们枚举5000个数内的质数就可以了

```
void solve() {
    get_primes(5000);  //获得1-5000内的所有素数，存放到primes中  素数的个数：cnt
    int res = 0;
    for (int c = 0; c < cnt; c++)
        for (int b = 0; b < c; b++)
            for (int a = 0; a < b; a++)
                if ((__int128)primes[a] * primes[b] * primes[b] * primes[c] * primes[c] * primes[c] <= n)
                    res++;

    cout << res << endl;
}
```

原题是一个二分的写法，大家可以思考一下：

​	枚举a和b，二分查找最大的c





>   [ACM/出题 at master · ProudCarrotG/ACM (github.com)](https://github.com/ProudCarrotG/ACM/tree/master/出题)测试数据在这里可以找到，但是都是随机数写的意义不大，还有我无比丑陋的std代码也在这里
>
>   (感觉题目难度和细节都把控得不够好，非常抱歉！)
